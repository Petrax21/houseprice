date: 2014-05-09 00:00:00
price: 376000.0
bedrooms: 3
bathrooms: 0
sqft_living: 2
sqft_lot: 0
floors: 1340
waterfront: 1384
view: 30
condition: 0
sqft_above: 9
sqft_basement: 3
yr_built: 1340
yr_renovated: 0
street: 2000
city: 0
statezip: 9245-9249 Fremont Ave N

```
#include <torch/torch.h>
#include <matplot/matplot.h>
#include "domain/house.hpp"
#include "domain/house_factory.h"
#include "domain/house_service.h"
#include "domain/house_repository.h"
#include "application/house_price_service.h"
#include <vector>
#include <string>
#include <algorithm>
#include <iostream>

struct NetReg : torch::nn::Module {
    torch::nn::Sequential layers;
    NetReg(int in, int hid) {
        layers = torch::nn::Sequential(
            torch::nn::Linear(in, hid),
            torch::nn::ReLU(),
            torch::nn::Dropout(0.2),
            torch::nn::Linear(hid, hid),
            torch::nn::ReLU(),
            torch::nn::Dropout(0.2),
            torch::nn::Linear(hid, 1)
        );
        register_module("layers", layers);
    }
    torch::Tensor forward(torch::Tensor x) {
        return layers->forward(x);
    }
};

torch::Tensor normalize(torch::Tensor t) {
    auto mean = torch::mean(t, 0);
    auto std = torch::std(t, 0);
    return (t - mean) / (std + 1e-8);
}

int main() {
    bool cuda = torch::cuda::is_available();
    int epochs = 300, hidden_size = 64;
    float learning_rate = 0.001;

    std::vector<House> train_houses = HouseRepository::load_from_csv("houseprice.csv");
    std::vector<House> test_houses = HouseRepository::load_from_csv("housepricetest.csv");

    std::cout << "Train house count: " << train_houses.size() << std::endl;
    std::cout << "Test house count: " << test_houses.size() << std::endl;
    if (!train_houses.empty()) {
        std::cout << "First train house: price=" << train_houses[0].price
                  << " bedrooms=" << train_houses[0].bedrooms
                  << " bathrooms=" << train_houses[0].bathrooms
                  << " sqft_living=" << train_houses[0].sqft_living
                  << " location=" << train_houses[0].location << std::endl;
    }

    std::vector<std::vector<float>> Xvec, Xtestvec;
    std::vector<float> yvec, ytestvec;
    for (const auto& h : train_houses) {
        Xvec.push_back({h.bedrooms, h.bathrooms, h.sqft_living});
        yvec.push_back(h.price);
    }
    for (const auto& h : test_houses) {
        Xtestvec.push_back({h.bedrooms, h.bathrooms, h.sqft_living});
        ytestvec.push_back(h.price);
    }

    auto X = torch::from_blob(Xvec.data(), {(int)Xvec.size(), 3}, torch::kFloat32).clone();
    auto y = torch::from_blob(yvec.data(), {(int)yvec.size()}, torch::kFloat32).clone();
    auto Xtest = torch::from_blob(Xtestvec.data(), {(int)Xtestvec.size(), 3}, torch::kFloat32).clone();
    auto ytest = torch::from_blob(ytestvec.data(), {(int)ytestvec.size()}, torch::kFloat32).clone();

    X = normalize(X);
    Xtest = normalize(Xtest);

    auto device = cuda ? torch::kCUDA : torch::kCPU;
    X = X.to(device);
    y = y.to(device);
    Xtest = Xtest.to(device);
    ytest = ytest.to(device);

    NetReg model(X.size(1), hidden_size);
    model.to(device);
    torch::optim::Adam opt(model.parameters(), learning_rate);

    std::vector<double> train_loss, test_loss;
    for (int epoch = 0; epoch < epochs; ++epoch) {
        model.train();
        auto out = model.forward(X).squeeze();
        auto loss = torch::mse_loss(out, y);
        opt.zero_grad();
        loss.backward();
        opt.step();
        model.eval();
        auto test_out = model.forward(Xtest).squeeze();
        auto tloss = torch::mse_loss(test_out, ytest);
        train_loss.push_back(loss.item<double>());
        test_loss.push_back(tloss.item<double>());
    }
    model.eval();
    auto preds = model.forward(Xtest).squeeze();
    auto mse = torch::mean(torch::square(preds - ytest)).item<double>();
    std::cout << "Test MSE: " << mse << std::endl;


    float user_bedrooms, user_bathrooms, user_sqft;
    std::cout << "Yatak odası sayısı gir: ";
    std::cin >> user_bedrooms;
    std::cout << "Banyo sayısı gir: ";
    std::cin >> user_bathrooms;
    std::cout << "Metrekare (sqft_living) gir: ";
    std::cin >> user_sqft;
    std::vector<std::vector<float>> user_Xvec = {{user_bedrooms, user_bathrooms, user_sqft}};
    auto user_X = torch::from_blob(user_Xvec.data(), {1, 3}, torch::kFloat32).clone();

    auto X_train = torch::from_blob(Xvec.data(), {(int)Xvec.size(), 3}, torch::kFloat32).clone();
    auto mean = torch::mean(X_train, 0);
    auto std = torch::std(X_train, 0);
    user_X = (user_X - mean) / (std + 1e-8);
    user_X = user_X.to(device);
    model.eval();
    auto user_pred = model.forward(user_X).item<float>();
    std::cout << "Tahmini fiyat: " << user_pred << std::endl;

    std::vector<double> epoch_vec(train_loss.size());
    std::iota(epoch_vec.begin(), epoch_vec.end(), 0);

    // stdout ve stderr'i bastır
    FILE* old_stdout = stdout;
    FILE* old_stderr = stderr;
    FILE* nullout1 = freopen("/dev/null", "w", stdout);
    FILE* nullout2 = freopen("/dev/null", "w", stderr);

    // Grafik çizimi
    matplot::figure();
    matplot::plot(epoch_vec, train_loss);
    matplot::hold(matplot::on);
    matplot::plot(epoch_vec, test_loss);
    matplot::title("House Price Regression - Loss");
    matplot::save("loss_houseprice.png");
    fflush(stdout);
    fflush(stderr);

    // stdout ve stderr'i geri yükle
    if (nullout1) fclose(stdout);
    if (nullout2) fclose(stderr);
    stdout = old_stdout;
    stderr = old_stderr;

    float avg_price = HouseService::mean_price(train_houses);
    std::cout << "Mean price: " << avg_price << std::endl;
    std::vector<float> pred_vec = HousePriceService::predict(model, test_houses, device);
    float mse2 = HousePriceService::mse(pred_vec, test_houses);
    std::cout << "MSE (HousePriceService): " << mse2 << std::endl;

    return 0;
}
```

    #include <torch/torch.h>
    #include <matplot/matplot.h>
    #include "domain/house.hpp"
    #include "domain/house_factory.h"
    #include "domain/house_service.h"
    #include "domain/house_repository.h"
    #include "application/house_price_service.h"
    #include <vector>
    #include <string>
    #include <algorithm>
    #include <iostream>
    #include <random>
    #include <cmath>
    #include <fstream>
    #include <numeric>

    struct NetReg : torch::nn::Module {
        torch::nn::Sequential layers;

        NetReg(int in, int hid) {
            layers = torch::nn::Sequential(
                torch::nn::Linear(in, hid),
                torch::nn::ReLU(),
                torch::nn::Dropout(0.2),
                torch::nn::Linear(hid, hid/2),
                torch::nn::ReLU(),
                torch::nn::Dropout(0.2),
                torch::nn::Linear(hid/2, 1)
            );
            register_module("layers", layers);
        }

        torch::Tensor forward(torch::Tensor x) {
            return layers->forward(x);
        }
    };

    torch::Tensor normalize(torch::Tensor t) {
        auto mean = torch::mean(t, 0);
        auto std = torch::std(t, 0);
        return (t - mean) / (std + 1e-8);
    }

    torch::Tensor log_transform(torch::Tensor t) {
        return torch::log1p(t);
    }

    torch::Tensor inverse_log_transform(torch::Tensor t) {
        return torch::exp(t) - 1;
    }

    double cubic_function(double x, double a, double b, double c, double d) {
        return a * x * x * x + b * x * x + c * x + d;
    }

    void solve4x4(double A[4][5]) {
        for (int i = 0; i < 4; ++i) {
            int maxRow = i;
            for (int k = i + 1; k < 4; ++k)
                if (fabs(A[k][i]) > fabs(A[maxRow][i])) maxRow = k;
            for (int k = i; k < 5; ++k) std::swap(A[maxRow][k], A[i][k]);
            for (int k = i + 1; k < 4; ++k) {
                double c = A[k][i] / A[i][i];
                for (int j = i; j < 5; ++j) A[k][j] -= c * A[i][j];
            }
        }
        for (int i = 3; i >= 0; --i) {
            A[i][4] /= A[i][i];
            A[i][i] = 1;
            for (int k = 0; k < i; ++k) {
                A[k][4] -= A[k][i] * A[i][4];
                A[k][i] = 0;
            }
        }
    }

    std::vector<double> cubic_fit(const std::vector<double>& x, const std::vector<double>& y) {
        int n = x.size();
        double Sx = 0, Sx2 = 0, Sx3 = 0, Sx4 = 0, Sx5 = 0, Sx6 = 0;
        double Sy = 0, Sxy = 0, Sx2y = 0, Sx3y = 0;
        for (int i = 0; i < n; ++i) {
            double xi = x[i], yi = y[i];
            double xi2 = xi*xi, xi3 = xi2*xi;
            Sx += xi;
            Sx2 += xi2;
            Sx3 += xi3;
            Sx4 += xi2*xi2;
            Sx5 += xi3*xi2;
            Sx6 += xi3*xi3;
            Sy += yi;
            Sxy += xi*yi;
            Sx2y += xi2*yi;
            Sx3y += xi3*yi;
        }
        double A[4][5] = {
            {Sx6, Sx5, Sx4, Sx3, Sx3y},
            {Sx5, Sx4, Sx3, Sx2, Sx2y},
            {Sx4, Sx3, Sx2, Sx,  Sxy },
            {Sx3, Sx2, Sx,  (double)n, Sy}
        };
        solve4x4(A);
        return {A[0][4], A[1][4], A[2][4], A[3][4]};
    }

    double cubic_eval(double x, const std::vector<double>& coeffs) {
        return coeffs[0]*x*x*x + coeffs[1]*x*x + coeffs[2]*x + coeffs[3];
    }

    int main() {
        bool cuda = torch::cuda::is_available();
        int epochs = 1000, hidden_size = 128;
        float learning_rate = 0.01;
        int patience = 100;

        std::vector<House> all_houses = HouseRepository::load_from_csv("houseprice.csv");

        std::cout << "Total house count: " << all_houses.size() << std::endl;
        if (!all_houses.empty()) {
            std::cout << "First house: price=" << all_houses[0].price
                      << " bedrooms=" << all_houses[0].bedrooms
                      << " bathrooms=" << all_houses[0].bathrooms
                      << " sqft_living=" << all_houses[0].sqft_living
                      << " location=" << all_houses[0].location << std::endl;
        }

        std::vector<House> filtered_houses;
        for (const auto& h : all_houses) {
            if (h.price >= 50000 && h.price <= 2000000 && h.bedrooms > 0 && h.bathrooms > 0 && h.sqft_living > 0) {
                filtered_houses.push_back(h);
            }
        }
        std::cout << "Filtered house count: " << filtered_houses.size() << std::endl;
        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(filtered_houses.begin(), filtered_houses.end(), g);
        int train_size = static_cast<int>(filtered_houses.size() * 0.8);
        std::vector<House> train_houses(filtered_houses.begin(), filtered_houses.begin() + train_size);
        std::vector<House> test_houses(filtered_houses.begin() + train_size, filtered_houses.end());

        std::vector<std::vector<float>> Xvec, Xtestvec;
        std::vector<float> yvec, ytestvec;
        for (const auto& h : train_houses) {
            Xvec.push_back({h.bedrooms, h.bathrooms, h.sqft_living});
            yvec.push_back(h.price);
        }
        for (const auto& h : test_houses) {
            Xtestvec.push_back({h.bedrooms, h.bathrooms, h.sqft_living});
            ytestvec.push_back(h.price);
        }
        auto X = torch::from_blob(Xvec.data(), {(int)Xvec.size(), 3}, torch::kFloat32).clone();
        auto y = torch::from_blob(yvec.data(), {(int)yvec.size()}, torch::kFloat32).clone();
        auto Xtest = torch::from_blob(Xtestvec.data(), {(int)Xtestvec.size(), 3}, torch::kFloat32).clone();
        auto ytest = torch::from_blob(ytestvec.data(), {(int)ytestvec.size()}, torch::kFloat32).clone();

        y = torch::log1p(y);
        ytest = torch::log1p(ytest);

        X = normalize(X);
        Xtest = normalize(Xtest);

        auto device = cuda ? torch::kCUDA : torch::kCPU;
        X = X.to(device);
        y = y.to(device);
        Xtest = Xtest.to(device);
        ytest = ytest.to(device);

        NetReg model(3, hidden_size);
        model.to(device);
        torch::optim::Adam opt(model.parameters(), learning_rate);

        std::vector<double> train_loss, test_loss;
        double best_test_loss = std::numeric_limits<double>::infinity();
        int no_improve_count = 0;

        for (int epoch = 0; epoch < epochs; ++epoch) {
            model.train();
            auto out = model.forward(X).squeeze();
            auto loss = torch::mse_loss(out, y);
            opt.zero_grad();
            loss.backward();

            torch::nn::utils::clip_grad_norm_(model.parameters(), 1.0);

            opt.step();

            model.eval();
            torch::NoGradGuard no_grad;
            auto test_out = model.forward(Xtest).squeeze();
            auto tloss = torch::mse_loss(test_out, ytest);

            double current_train_loss = loss.item<double>();
            double current_test_loss = tloss.item<double>();

            train_loss.push_back(current_train_loss);
            test_loss.push_back(current_test_loss);

            if (current_test_loss < best_test_loss) {
                best_test_loss = current_test_loss;
                no_improve_count = 0;
            } else {
                no_improve_count++;
            }

            if (no_improve_count >= patience) {
                std::cout << "Early stopping at epoch " << epoch << std::endl;
                break;
            }

            if (epoch % 100 == 0) {
                std::cout << "Epoch " << epoch << " - Train Loss: " << current_train_loss
                          << " - Test Loss: " << current_test_loss << std::endl;
            }
        }

        model.eval();
        torch::NoGradGuard no_grad;
        auto preds = model.forward(Xtest).squeeze();
        auto mse = torch::mean(torch::square(preds - ytest)).item<double>();
        std::cout << "Test MSE (log scale): " << mse << std::endl;

        float user_bedrooms, user_bathrooms, user_sqft;
        std::cout << "Yatak odası sayısı: ";
        std::cin >> user_bedrooms;
        std::cout << "Banyo sayısı: ";
        std::cin >> user_bathrooms;
        std::cout << "Metrekare: ";
        std::cin >> user_sqft;
        std::vector<std::vector<float>> user_Xvec = {{user_bedrooms, user_bathrooms, user_sqft}};
        auto user_X = torch::from_blob(user_Xvec.data(), {1, 3}, torch::kFloat32).clone();
        auto X_train = torch::from_blob(Xvec.data(), {(int)Xvec.size(), 3}, torch::kFloat32).clone();
        auto mean = torch::mean(X_train, 0);
        auto std = torch::std(X_train, 0);
        user_X = (user_X - mean) / (std + 1e-8);
        user_X = user_X.to(device);

        model.eval();
        auto user_pred_log = model.forward(user_X).item<float>();

        if (std::isnan(user_pred_log) || std::isinf(user_pred_log)) {
            std::cout << "Hata: Geçersiz tahmin sonucu. Lütfen farklı değerler deneyin." << std::endl;
            return 0;
        }

        float user_pred = std::exp(user_pred_log) - 1;

        if (user_pred < 0) {
            user_pred = std::abs(user_pred);
        }

        if (user_pred < 50000) user_pred = 50000;
        if (user_pred > 2000000) user_pred = 2000000;

        std::cout << "Tahmini fiyat: " << user_pred << " USD" << std::endl;

        std::vector<double> epoch_vec(train_loss.size());
        std::iota(epoch_vec.begin(), epoch_vec.end(), 0);

        std::ofstream loss_file("loss_data.txt");
        for (size_t i = 0; i < train_loss.size(); ++i) {
            loss_file << epoch_vec[i] << " " << train_loss[i] << " " << test_loss[i] << std::endl;
        }
        loss_file.close();

        FILE* old_stdout = stdout;
        FILE* old_stderr = stderr;
        FILE* nullout1 = freopen("/dev/null", "w", stdout);
        FILE* nullout2 = freopen("/dev/null", "w", stderr);

        matplot::figure();
        matplot::plot(epoch_vec, train_loss, "b-");
        matplot::hold(matplot::on);
        matplot::plot(epoch_vec, test_loss, "r-");
        matplot::title("Loss (Train: blue, Test: red)");
        matplot::xlabel("Epoch");
        matplot::ylabel("Loss (MSE)");
        matplot::legend({"Train Loss", "Test Loss"});
        matplot::grid(matplot::on);
        matplot::save("loss_train_test.png");
        matplot::show();

        fflush(stdout);
        fflush(stderr);
        if (nullout1) fclose(stdout);
        if (nullout2) fclose(stderr);
        stdout = old_stdout;
        stderr = old_stderr;

        std::cout << "Grafik penceresi açıldı. Kapatmak için Enter'a basın..." << std::endl;
        std::cin.get();

        float avg_price = HouseService::mean_price(train_houses);
        std::cout << "Mean price: " << avg_price << std::endl;
        std::vector<float> pred_vec = HousePriceService::predict(model, test_houses, device);
        float mse2 = HousePriceService::mse(pred_vec, test_houses);
        std::cout << "MSE (HousePriceService): " << mse2 << std::endl;

        return 0;
    }